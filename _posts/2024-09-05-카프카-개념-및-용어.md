---
title: "[Kafka] 카프카의 주요 개념 및 용어"
categories:
  - kafka
tags:
  - kafka
toc: true
toc_sticky: true
---


# 주요 개념 및 용어
![image](/assets/images/kafka/20240905_1.png)
- `KafkaCluster`
  - 카프카의 브로커(broker)들의 모임 => 확장성과 고가용성을 위해서 borker들이 클러스터로 구성
  - 보통 3개 이상으로 구성하는 것을 권장한다고 한다
  - 설정은 어떻게..? 하는거지? => 찾아보니 설정 파일로 조정하는게 아니라 실제로 추가하거나 제거하는 작업을 해야한다고 함! 어렵구먼
- `Broker`
  - 각각의 카프카 서버
- `Zookeeper`
  - 카프카 클러스터 정보 및 분산처리 관리 등 메타데이터 저장
  - 곧 카프카 클러스터랑 통합 예정이라는데 언제쯤..?
- `Producer`
  - 메세지를 발행하여 생산하는 주체
  - 쉽게 말해 카프카에 메세지를 보내기
- `Consumer`
  - 메세지를 구독하여 소비하는 주체
  - 쉽게 말해 카프카에서 메세지를 꺼내 읽기

## 카프카의 상세 구조 : 토픽, 파티션, 오프셋
![image](/assets/images/kafka/20240905_2.png)
- `Topic`
  - 메세지를 구분하는 단위
  - 폴더와 유사하다고 생각하면 쉽다
- `Partition`
  - 메세지를 저장하는 물리적인 파일
  - 폴더안에 들어있는 파일들이라고 생각하면 쉽다
  - 한개의 토픽은 한개의 파티션으로 구성되어 있음
  - 파티션은 메세지 추가만 가능함
- `Offset`
  - 파티션 내 각 메세지가 저장되어있는 상대적인 위치
  - 프로듀서가 넣는 메세지는 파티션의 맨 뒤에 추가 된다 => 왜냐면 카프카는 `Queue`형태니깐
  - 컨슈머는 `offset` 기준으로 순서대로 메세지를 읽음
  - 파티션의 메시지 파일은 처리 후에도 계속 저장되어 있어 설정에 따라 일정시간 뒤 삭제됨
    - 설정은 어디서..하는거지?
- `Replication`
  - 파티션의 복제
  - `Leader partition`과 `Follower partition`은 파티션의 데이터 복제 및 고가용성을 위해 사용
  - ISR(In-Sync Replicas) : 리더와 동기화된 복제본들의 집합
  - 데이터의 일관성을 보장하고 장애 발생 시 데이터 손실을 최소화하는데 중요한 역할 => 가용성 보장!

# Zookeeper
- 분산 코디네이션 서비스
  - 분산 시스템에서 시스템 간의 정보공유, 상태체크, 서버들 간의 동기화를 위한 락 등을 처리해주는 서비스
- 카프카에서 주키퍼의 역할은?
  - 서버의 상태를 감지하기 위해 사용됨
  - 새로운 토픽이 생성되었을 때 토픽의 생성과 소비에 대한 상태를 저장

# Broker
- Message Broker
  - publisher가 생산한 메시지를 메시지 큐에 저장하고, 저장된 데이터를 consumer가 가져갈 수 있게 하는 역할
  - 보통 서로 다른 시스템 사이에서 데이터를 비동기 형태로 처리
  - 대표적인 예) RabbitMQ, RedisQueue 등 
- Event Broker
  - 기본적으로 Message Broker의 기능들을 가지고 있음
  - publisher가 생산한 이벤트를 저장하여 후에 consumer가 특정 시점부터 이벤트를 다시 소비할 수 있음
  - 장애가 일어났을 때 장애가 일어난 시점부터 재처리 가능 => 어떤 원리로 가능하지..?
  - 많은 양의 실시간 스트림 데이터를 효과적으로 처리할 수 있음
  - 대표적인 예) Kafka, 키네시스 등

# Producer
- 메세지를 발행하여 생산하는 주체
- 프로듀서는 메시지 전송 시 토픽을 지정할 수 있고, 파티션 번호를 지정할 수 있음
  - 파티션 번호를 지정했다면 동일한 파티션 번호에 메세지가 저장됨
  - 파티션 번호가 없다면? 라운드로빈 방식으로 적절하게 분배됨

# Consumer
- 데이터를 읽어오는 클라이언트 애플리케이션
  - 메세지 읽기 : 카프카 브로커에 저장된 메세지를 가져와 처리
  - 오프셋 관리 : 컨슈머는 메세지를 읽을 때 각 메세지의 오프셋(위치)을 관리하여 이미 처리한 메세지를 다시 읽지 않도록 함
  - 그룹화 : 여러개의 컨슈머가 그룹을 이루어 메세지를 병렬로 처리 가능 -> 이 경우에는 각 메세지는 한 컨슈머만 처리할 수 있음
  - 재시도 및 오류 처리 : 메세지를 처리하는 과정에서 오류가 발생하면 재시도 로직을 구현하여 실패한 메세지를 다시 읽을 수 있음 -> 우리회사 경우 `Retry` 토픽을 하나 생성해서 실패시 Retry 토픽에 메세지를 재 프로듀싱하는 작업으로 재시도 로직을 구현하였음

# Partition
- 데이터의 병렬처리 및 분산 저장을 가능하게 해 카프카의 확장성과 성능을 높일 수 있음
- 파티션이 많으면 많을수록 더 많은 데이터를 처리할 수 있고, 더 많은 Consumer와 Producer를 지원할 수 있음
  - 하지만 너무 무분별하게 늘리면 안됨! 왜냐면 파티션은 한번 늘어나면 다시 줄이기 쉽지 않기 때문
  - 그 이유는 데이터 분산 및 일관성 유지가 어렵기 때문,,,
  - 파티션을 줄이기보다는 새로운 토픽을 생성 혹은 데이터 마이그레이션 혹은 클러스터 모니터링을 통해서 파티션을 줄이는 동안 충분한 모니터링이 필요함!

# 출처
- https://ifuwanna.tistory.com/487
- https://medium.com/@0joon/10%EB%B6%84%EC%95%88%EC%97%90-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-kafka-bed877e7a3bc
